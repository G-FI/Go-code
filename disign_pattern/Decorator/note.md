1. 装饰模式是一种结构型设计模式， 允许你通过将**对象**放入包含行为的**特殊封装对象**中来**为原对象绑定新的行为**。 
2. **装饰和代理有相似结构**两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。
需要的类、接口：
    1. **基本组件类**
    2. 根据基本组件提取出来的**接口**
    3. 基础装饰器类(内含一个接口引用，使用基本组件提供的功能)
    4. 扩展的装饰器类(对基本组件的功能进行扩展)
实现方式：
    1. 确保业务逻辑可用一个基本组件及多个额外可选层次表示。
    2. 找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法。
    3. 创建一个具体组件类， 并定义其基础行为。
    4. 创建装饰基类， 使用**一个成员变量存储指向被封装对象的引用**。 该成员变量必须被声明为组件接口类型， 从而能在运行时连接具体组件和装饰。 装饰基类必须将所有工作委派给被封装的对象。
    5. 确保所有类实现组件接口。
    6. 将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。
    7. 客户端代码负责创建装饰并将其组合成客户端所需的形式。
补充：
    1. 目的和继承一样，都是扩展具体组件类的功能
    2. 我觉得比继承的好处就是，**可以运行时一层一层的wrapper，每wrapper一层就扩展一个功能**
    3. 继承实现功能组合需要**好多层**，而具体装饰类只需要一层
    4. **主要区别：继承在编写代码时实现不同扩展的组合(需要硬编码，继承体系庞大)，而装饰是在运行时扩展功能的组合**
    5. 前提：扩展**最好**可以分为无关的多个层，每层写一个装饰类，如果相关，就必须在装饰时注意顺序